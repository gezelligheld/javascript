当js执行一段代码时便会创建一个执行上下文，包括变量对象、作用域链、this，上下文在其所有代码执行完毕后会被销毁，包括定义在上面的所有变量和函数。执行一段代码的大致过程如下

1. 创建全局上下文

2. 全局执行上下文自上而下执行，遇到函数时，函数执行上下文被push到执行栈顶层

3. 函数执行上下文被激活，成为活动对象，开始执行函数中的代码，全局执行上下文被挂起

4. 函数执行完后移出执行上下文栈，控制权交还全局上下文，继续执行

变量和函数的上下文决定了它们可以访问哪些数据，以及它们的行为，每个上下文都有一个关联的变量对象，上下文所定义的变量和函数都存在于这个变量对象中

#### 全局上下文

全局上下文是最外层的上下文，根据宿主环境的不同，表示全局上下文的对象可能也不同，在浏览器环境中，表示全局上下文的对象是window对象，因此通过var定义的全局变量和函数会成为window的属性和方法

全局上下文会在应用程序退出前才会被销毁，比如关闭网页

#### 函数上下文

当代码执行到函数时，函数的上下文会被推到一个上下文栈中，函数执行完毕后上下文栈会弹出该函数的上下文

活动对象是函数上下文的变量对象，在进入函数上下文时被创建

#### 作用域链

上下文代码还在执行时，会创建作用域链，决定了各级上下文的代码访问变量和函数的顺序

代码正在执行的上下文的变量对象位于作用域链的最前端

作用域链的下一个变量对象来自上层作用域的上下文，以此类推直到全局上下文，全局上下文的变量对象始终是作用域链的最后一个变量对象

#### 临时的上下文

某些语句会导致在作用域链前端临时添加一个上下文，又在代码执行后删掉

- try/catch语句的catch：创建的上下文中的变量对象包含要抛出的错误对象的声明
- with：会将指定的对象添加到作用域链前端

```js
function demo(){
    let qs = "?a=1";
    with (location) {
        // 这里的上下文为location对象
        let url = href + qs;
    }
    return url;
}
```

#### 再谈变量声明

- var

在使用var声明变量时，变量会被自动添加到最近的上下文，在函数中最近的就是函数上下文；如果未经声明就初始化了，会自动被添加到全局上下文中

var声明被拿到函数或全局作用域的顶部，称之为提升

- let、const

let、const的作用域是块级的，块级作用域由最近的一组花括号界定