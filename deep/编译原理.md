#### v8 引擎

编程语言可以分为机器语言、汇编语言、高级语言

- 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性
- 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识
- 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行

也就是说，高级语言一定要转化为机器语言才能被计算机执行，高级语言又可以分为解释型语言和编译型语言

- 编译型语言：需要编译器进行一次编译，被编译过的文件可以多次执行。如 C++、C 语言
- 解释型语言：不需要事先编译，通过解释器一边解释一边执行。启动快，但执行慢

javascript 是一种高级语言，由于是动态类型语言，定义变量是没有类型的限制，运行时才能收集类型信息，所以 javascript 也是一种解释型语言。javascript 要想执行必须被 javascript 引擎解析和运行，V8 是 Google 基于 C++ 编写的开源高性能 Javascript 与 WebAssembly 引擎，用于 chrome 浏览器和 nodejs 等，其中有几个主要的模块

- 解析器：将 js 代码转换为 AST
- 解释器：将 AST 转换字节码并执行，同时收集优化编译所需的信息。字节码某种程度上就是汇编语言，只是它没有对应特定的 CPU，所以相比于真正的汇编语言会简单很多
- 编译器：利用解释器收集的信息，将字节码优化编译为汇编码
- 垃圾回收模块：将程序不再需要的内存空间回收

#### CPU 执行机器指令

将高级语言转化为机器语言之后的流程如下

1. 程序在执行之前会被装进内存
2. 将二进制代码中的第一条指令的地址写入到 CPU 的 PC 寄存器（程序计数寄存器）中
3. CPU 根据 PC 寄存器中的地址，从内存中取出指令，将下一条指令的地址更新到 PC 寄存器中
4. 分析当前取出指令，并识别出不同的类型的指令，以及各种获取操作数的方法
5. 加载指令，从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容
6. 存储指令，将寄存器中的内容复制到内存某个位置，并覆盖掉内存中的这个位置上原来的内容
7. 更新指令，复制两个寄存器中的内容到 ALU （算术逻辑运算部件）中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容
8. 执行指令完毕，进入下一个 CPU 时钟周期

#### v8 引擎编译流程

##### 初始化基础环境

V8 执行 Js 代码是离不开宿主环境的，V8 的宿主可以是浏览器，也可以是 Node.js。在浏览器中当打开一个渲染进程时，就为 V8 初始化了一个运行时环境，为 V8 提供了堆空间、栈空间、全局执行上下文、消息循环系统、宿主对象及宿主 API 等

##### 解析源码

源码只是一些字符串，解析器会将其结构化。以下列代码举例说明

```js
var a = 10;
```

首先词法分析，将字符串分解成有意义的代码块，称为词法单元（token）

```
var，a，=，10
```

语法分析，将词法单元转换成一个由元素逐级嵌套的代表了程序语法结构的树，称为抽象语法树（AST），编译器和解释器后续工作都要依靠 AST，同时也生成了作用域

##### 生成字节码

解释器将 AST 生成为字节码，由于汇编码体积过大，直接生成会引起内存问题

##### 解释执行字节码

使用内存中的一块区域来存放字节码，通用寄存器用来存放一些中间数据，PC 寄存器用来指向下一条要执行的字节码，栈顶寄存器用来指向当前的栈顶的位置

![](https://pic3.zhimg.com/80/v2-b3a3e88341d762bb7467ca2941e4c356_1440w.webp)

##### 即时编译

JS 是解释型语言且弱类型，在生成 AST 之后，就开始一边编译，一边解释，这种字节码、编译器、解释器相结合的技术，称为即时编译 JIT

- 监视器

在解释器执行字节码时，监视器会对代码进行分析，跟踪不同的语句被命中的次数，随着次数的不断增长，该语句会被标记为 warm、hot、very hot；换言之，监视器会检测哪些部分的代码被使用最多，然后将它们进行编译和存储。编译器会针对这些代码逐行进行机器码编译，然后存储在一张表的单元中；之后遇到它们时直接执行相应的机器码，不用再次将转换为机器码

    - warm 将解释执行代码发送给 JIT 引擎，将其编译为机器码，但此处不会进行替换
    - hot 解释执行代码将被替换为 warm 编译出的机器码执行
    - very hot 将解释执行的代码发送给优化编译器，创建和编译出更高效的机器码执行代码并进行替换

但是，如果前 99 个对象属性保持着 INT 类型，可能第 100 个就没有这个属性了，那么这时候 JIT 会认为做了一个错误的假设，并且把优化代码丢掉，执行过程将会回到解释器或者基线编译器

- 基线编译器

warm 部分的代码送到基线编译器去编译，并且把编译结果存储起来，监视器监视到了某行、某个变量执行同样的代码、使用了同样的变量类型，就会把编译后的版本，替换这一行代码的执行，并且存储

例如

```js
function concat(arr) {
  let res = '';
  for (let i = 0; i < arr.length; i++) {
    res += arr[i];
  }

  return res;
}

console.log(concat(['a', 1, 'b', true, 'c']));
```

基线编译器会将 res += arr[i]转换为存根，但由于此指令是多态的（没有什么能保证 i 每次都是一个整数或 arr[i]每次都为一个字符串），它将为每个可能的组合创建存根

- 优化编译器

hot 部分的代码送到优化编译器去编译，将所有这些孤立的存根变成一个组，如果可能会尽可能的对整个函数进行存根，生成一个更快速和高效的代码版本出来

以上就是 v8 引擎执行一段 js 代码的过程，总结为以下 3 个步骤

1. 通过词法分析和语法分析生成 AST
2. 将 AST 转换为字节码
3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率

#### 利用 JIT 优化代码

- 不要改变对象的形状

由于对 car1、car2 添加了其他属性，编译器不能再假设 car1、car2 同属于一个类，这就需要创建新的类；改变越大，监视器越去跟踪，最终会丢掉所有的优化选项

```js
class Car {
  constructor(color, made, model) {
    this.color = color;
    this.made = made;
    this.model = model;
  }
}

const car1 = new Car('red', 'chevrolet', 'spark');
const car2 = new Car('blue', 'hyundai', 'tucson');

car1.doors = 2;
car2.radio = true;
```

- 保持函数参数不变

更改用于调用函数的属性类型越多，在编译器眼中，函数就变得越复杂。优化器将尝试为用于属性的每个可能的组合创建存根，所以如果总是将字符串传递给函数，监视器将假定这是它所需的唯一类型，将其标记为单形，在快速查找表上跟踪它，如果此时再传入不同的类型，内部查找表将开始增长，因为现在已经将函数转换为多态函数

如果继续使用更多的类型组合来调用它，可能会丢掉所有内部优化

```js
function yourFunction(a, b) {
  //... your logic goes here
}

yourFunction(1, 2); // monomorphic
yourFunction('string a', 'string b'); // now it's polymorphic...
yourFunction(true, false);
yourFunction(1, 'string c');
yourFunction(false, (err) => {
  // oops, now it's megamorphic
  //....
});
```

#### v8 优化策略

1. 引入字节码

直接将 JavaScript 代码编译成机器代码。这样做带来的问题有两点，一是需要较长的编译时间，二是产生的二进制机器码需要占用较大的内存空间。

使用字节码可以节省内存空间并且降低编译时间，也降低了 v8 的复杂度，因为字节码不和 CPU 关联，不需要适配不同的 CPU

2. 延迟解析

一方面并不是所有 js 代码会在初始化的时候执行，另一方面一次性解析所有的代码也会有耗时过长、占用内存过多的问题，因此只有立即执行的函数才会被完全解析，即生成 AST 和字节码，其他函数只有等到执行的时候才会被完全解析

3. 隐藏类

v8 在执行以下代码时会为对象创建一个隐藏类，每个对象都有一个 map 属性，其值指向内存中的隐藏类。隐藏类描述了对象的属性布局，它主要包括了属性名称和每个属性所对应的偏移量。这样当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，大大提升了 V8 查找对象的效率

```js
let point = { x: 100, y: 200 };
```

4. 快属性与慢属性

当对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式（快属性）降级为非线性的字典存储模式(慢属性)，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度

5. 内联缓存

如下的代码，获取 o.x 时，首先查找对象 o 的隐藏类，然后查找 x 属性的偏移量，根据偏移量获取其属性值

```js
function loadX(o) {
  o.y = 4;
  return o.x;
}

var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6 };

for (var i = 0; i < 90000; i++) {
  loadX(o);
  loadX(o1);
}
```

但是 loadX 被反复执行，获取属性值的流程也会不断被执行，为了提升查找效率，v8 会为每个函数维护一个反馈向量，记录了函数在执行过程中的一些关键的中间数据，也就是将对象的隐藏类记录在反馈向量中，然后将这些数据缓存起来，当下次再次执行该函数时直接读取即可

参考

1. [JavaScript 深入浅出第 4 课：V8 引擎是如何工作的？](https://zhuanlan.zhihu.com/p/73768338)
2. [js 代码是如何运行的](https://zhuanlan.zhihu.com/p/383959486)
