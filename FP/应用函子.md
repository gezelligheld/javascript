#### 应用函子（Applicative Functor）

如下，向Box容器中传入一个函数，

```js
const Box = x => ({
    map: f => Box(f(x)),
})

const addOne = x => x + 1
Box(addOne);
```

创建一个apply方法，可以向addOne传递参数

```js
const Box = x => ({
    map: f => Box(f(x)),
    apply: o => o.map(x),
})
Box(addOne).apply(Box(2)) // Box(3)

// 这两者结果是相同的
Box(2).map(addOne) == Box(addOne).apply(Box(2))
```

上述问题可以归结为，将一个函子应用到了另一个函子上，其中 Box(addOne) 就是应用函子

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e7e69eaece849a1aa24163e3d50bb72~tplv-k3u1fbpfcp-watermark.awebp)

##### 应用函子与柯里化

如下，add是一个柯里化的相加函数，我们期望将Box(1)和Box(2)相加得到Box(3)，这样显然不行，值都在容器里，不能直接操作

```js
const add = x => y => x + y

add(Box(1))(Box(2))
```

可以利用应用函子，然后再继续apply其他函子，每apply一个函子，相当于把应用函子中注入的柯里化函数降元一次

```js
Box(add).apply(Box(1)).apply(Box(2))  // => Box(3) (得到最终的结果)
```

##### 应用函子和函子的区别和联系

应用函子是函子的拓展

- 函子只能映射一个接收单个参数的函数，是应用了一个函数到被容器包裹的值，如Box(1).map(x => x + 1)

- 应用函子可以映射一个接收多个参数的函数，是应用了一个被容器包裹的函数到包裹的值，如Box(x => x + 1).apply(Box(1))