# javascript 总结

- basic 基础
- deep 深入
- es6+ es6+特性
- regexp 正则
- example 例子
- OOP 面向对象编程
- FP 函数式编程
- DP 设计模式

#### todo

- 设计模式

- 函数式编程和面向对象编程

#### 知识点

##### 数据类型（number、string、boolean、object、symbol、bigInt、null、undefined）

##### 类型检测（===、typeof、instanceof、Object.prototype.toString.call、constructor）

##### 声明类型（let、const、var）

##### 原型和原型链（构造函数、prototype、\_\_proto\_\_、constructor）

##### 数组（数组方法、类数组、类型化数组，遍历数组 for、for of、for in、扁平化、去重）

##### this（默认绑定，隐式绑定、绑定丢失，显式绑定 apply、call、bind，new，绑定例外）

##### 作用域和作用域链（静态作用域）

##### 闭包（特点、如何形成）

##### 继承（类式继承、构造函数继承、组合继承、原型继承、寄生继承）

##### 执行上下文（执行上下文栈、变量对象、this、作用域链、全局上下文、函数上下文、临时上下文）

当 js 执行一段可执行的代码时，会创建执行上下文，其中包括了变量对象、this、作用域链，并创建一个执行上下文栈来管理执行上下文

- 执行一段代码时，进入全局首先创建全局执行上下文，压入执行上下文栈，全局上下文的变量对象就是全局对象 window

- 遇到函数时创建函数执行上下文栈并压入执行上下文栈，创建活动对象，未执行函数前的变量对象是不能访问其内部的属性的；创建作用域链，当前作用域链的最前端就是正在执行的这个函数的变量对象，当查找变量时，会先从当前执行上下文的变量对象查找，如果没有就从上一层执行上下文的变量对象中查找，直到全局；创建了 this，也就是说 this 指向是在函数调用创建执行上下文的时候确定的

- 当函数执行完毕后，弹出执行上下文栈，活动对象也随之销毁；全局上下文始终存在，直到应用程序退出

> 闭包比较特殊，当内部函数引用了外部函数的变量时，此时的作用域链中依然存在对外部函数活动对象的引用，并未销毁

##### 内存机制（栈内存，堆内存 老生代、新生代，内存生命周期，垃圾回收算法 引用计数、增量标记）

对象存储在堆内存中，其余简单数据类型存储在栈内存中，栈内存还承担了创建和切换执行上下文的工作，所以没有保存对象这样复杂的数据类型。

在声明变量时 js 会自动分配内存，栈内存中当前函数执行完成后栈顶的空间会自动释放，而堆内存分为了新生代内存和老生代内存

- 新生代内存是临时分配的内存，新生代又分为 from 和 to 两部分，from 是正在使用的内存，to 是闲置的内存，当垃圾回收时，将 from 部分存活的对象顺序放到 to 中，当检查完毕后 to 变成了正在使用的内存，from 闲置，这样是为了整理内存碎片

- 新生代内存中回收多次依然存在的内存进入老生代内存，老生代内存是常驻内存，当垃圾回收时分为标记和清除两个阶段，标记所有对象将被引用的对象取消标记，将其余的清除，清除会使得内存不连续（内存碎片），需要将存活的对象向一端靠拢清除内存碎片

垃圾回收是一个比较耗时的过程，会阻塞 js 引擎线程，这里将垃圾回收任务拆成一小部分一小部分地执行，类似 react 的调度机制

##### 编译原理（词法分析->语法分析->边编译，即生成字节码，边解释，即执行字节码->热点代码编译成机器码）

首先将 js 代码通过词法分析解析为词法单元，再通过语法分析将词法单元解析为抽象语法树 ast，将 ast 解析为字节码，直接解析为机器码代码体积太大了，然后一边解释一遍编译，由解释器逐行解析字节码将其转为机器码执行。执行过程中，如果遇到出现频次较高的代码，编译器会将其直接转为机器码，当再次遇到相同的代码时直接执行机器码，用来提高执行效率

##### 正则（量词，匹配优先、忽略优先，修饰符，零宽断言，捕获）

##### 集合和映射（Set、Map、WeakSet、WeakMap，使用场景）

##### 迭代器和可迭代对象（generator、async await）

##### Promise（all、allSettled、race、any，实现）

##### 模块加载方案（amd、cmd、commonjs、esm，amd&cmd，commonjs&cmd，esm&commonjs）

##### es6 其他（模板字符串、proxy、箭头函数等）

##### 其他（深浅拷贝、私有变量、乱序、防抖和节流、事件总线等）

##### 函数式编程（柯里化、组合、函子、应用函子、单子）

##### 设计模式（单例、工厂、抽象工厂、原型、观察者等）
